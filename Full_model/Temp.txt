if t == 1
    num_this_batch = num_trials_first;
    index_this_batch = 1:num_trials_first;
    start_this_batch = 0;
    X_next = zeros(size(pi_dense_local,1), num_this_batch);
    X_next_all = zeros(size(pi_dense_all,1), num_this_batch);
    for l = 1:num_this_batch
        locations_next = randsample(grid_index, num_sources);
        locations_trials(start_this_batch+l,:)=locations_next;
        X_next(:,l) =  sum(pi_dense_local(:, locations_next) ,2);
        X_next_all(:,l) = sum(pi_dense_all(:,locations_next),2);
    end
else
    num_this_batch = num_trials_batch;
    index_this_batch = num_trials_first + (t-2)*num_trials_batch + (1:num_trials_batch);
    start_this_batch = num_trials_first + (t-2)*num_trials_batch;
    
    if design == 0
        % Random design
        %entropy_locations = pi_dense_local'*ones(n_cell_local,1);
        idx = randsample(grid_index, num_peaks);
    elseif design == 1
        % Optiml design
        %--------------------------------------------------%
        % Part I: evaluate the entropies
        delta_H = zeros(n_cell_local+1,1);
        for j = 1:(num_threshold)
            H_current = per_neuron_joint_entropy(output(j).alpha, ...
                output(j).mu, output(j).s_sq);
            Y_n = Y_g(1:start_this_batch,j);
            
            if sqrt_transform
                % Variance stablization transformation
                Y_n = sqrt(Y_n);
            end
            if  sum(Y_n)==0 % prevent zero standard deviation
                hyperparam_sigma_n = 1;
            else
                hyperparam_sigma_n = std(Y_n);
            end
            
            H_expected = approximate_expected_joint_entropy_single_neuron_poisson(...
                output(j).alpha, output(j).mu, ...
                output(j).s_sq, hyperparam_sigma_n, num_samples);
            delta_H = delta_H + H_current-H_expected;
            
        end
        entropy_locations = pi_dense_local'*delta_H(2:end);
        
        idx = [];
        for i = 1:num_peaks
            [m_id temp_idx] = max(entropy_locations);
            idx = [idx temp_idx];
            entropy_locations = entropy_locations - inner_normalized_products(:,temp_idx)*m_id;
        end
    end
    
    % Find multiple treaments:
    % Permute the index vector
    num_rep = ceil(num_sources*num_this_batch/num_peaks);
    idx_seq = zeros(num_rep*num_peaks,1);
    for l = 1:num_rep
        idx_seq((l-1)*num_peaks+(1:num_peaks)) = randsample(idx, num_peaks);
    end
    X_next = zeros(size(pi_dense_local,1), num_this_batch);
    X_next_all = zeros(size(pi_dense_all,1), num_this_batch);
    for l = 1:num_this_batch
        locations_next = idx_seq((l-1)*num_sources + (1:num_sources));
        locations_trials(start_this_batch+l,:)=locations_next;
        X_next(:,l) = sum(pi_dense_local(:, locations_next) ,2);
        X_next_all(:,l) = sum(pi_dense_all(:,locations_next),2);
    end
end
