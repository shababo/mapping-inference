%% One instance in the experiment:

% experiment_setup, neighbourhoods(neighbourhood_ID)

%% Grab new members

% Need a function for this 
%% Design new trials 

% We can parfor this step: 
unique_group_names=unique([neighbourhoods(neighbourhood_ID).neurons(:).group_type_ID]);

parfor i_group =1:length(unqiue_group_names)
    group_type_ID=unique_group_names(i_group);
    this_group_ID=index([experiment_setp.groups(:).group_type_ID]==group_type_ID); 
    
[experiment_query] = random_design(...
            );
        [mpp_temp] = draw_samples(...
            trials_locations, trials_powers, pi_target_truth, background_rate,...
            cell_params(related_cell_list), current_template, funcs, delay_params,stim_threshold,time_max);
        [mpp_temp.batch]=deal(iter);
        if isempty(mpp_undefined)
            mpp_undefined=mpp_temp;
        else
            mpp_undefined(end+(1:+length(mpp_temp)))=mpp_temp;
        end
        n_trials=n_trials+length(mpp_temp);
    end
    
    
    
    % Initialize the path of variational families with infor from previous
    % iteratin
    variational_params_path(iter+1,:)=variational_params_path(iter,:);
    parameter_path(iter+1,:)=parameter_path(iter,:);
    
tstart=toc;
    %------------------------------------------------------%
    % Fit VI on Group A: the undefined cells
    if num_trials_undefined>0
        % Find stimulated cells in these trials
        
        indicators_remained = find(ismember([mpp_undefined(:).batch],iter-(0:num_trace_back) ));
        mpp_remained=mpp_undefined(indicators_remained);
        trials_locations=reshape([mpp_remained(:).locations],n_spots_per_trial,[])';
        trials_powers=reshape([mpp_remained(:).power],n_spots_per_trial,[])';
        designs_remained = get_stim_size(pi_target,trials_locations,trials_powers);
           
        % include all cells that have been stimulated:
        cell_list= find(sum(designs_remained>stim_threshold,1)>0);
        designs_remained=designs_remained(:,cell_list);
        % Update variational and prior distribution
        variational_params=variational_params_path(iter,cell_list);
        prior_params=variational_params_path(max(iter-num_trace_back,1),cell_list);
        switch model_type
            case 1% working model
                lklh_func=@calculate_loglikelihood_bernoulli;
            case 2% working model with spike & slab
                lklh_func=@calculate_loglikelihood_bernoulli;
            case 3 % full model with first spike
                lklh_func=@lif_glm_firstspike_loglikelihood_for_VI;
            case 4 % full model with first event 
                lklh_func=@lif_glm_firstevent_loglikelihood_for_VI;
            otherwise
        end
        [parameter_history] = fit_VI(...
            designs_remained, mpp_remained, background_rate, ...
            prob_trace_full,stim_scale,minimum_stim_threshold,...
            variational_params,prior_params,gamma_bound,gain_bound,...
            S,epsilon,eta,eta_max,maxit,lklh_func,spike_indicator);
        
        variational_params_path(iter+1,cell_list)=parameter_history(end,:);
        
        [parameter_temp] = calculate_posterior(parameter_history(end,:),gamma_bound,gain_bound,quantiles_prob,spike_indicator);
        parameter_path(iter+1,cell_list)=parameter_temp;
        
        %----------------------------------------%
    end
     tend=toc;
     computing_time(1).multi(iter)=tend-tstart;

  
    
    [new_list]= move_cells(...
        connected_threshold,disconnected_threshold,single_spot_threshold,multispot_change_threshold,...
        dead_cells{iter},disconnected_cells{iter},undefined_cells{iter},connected_cells{iter},alive_cells{iter},...
        variational_params_path, parameter_path,assignment_type);
    
    disconnected_cells{iter+1}=new_list.disconnected_cells;
    undefined_cells{iter+1}=new_list.undefined_cells;
    connected_cells{iter+1}=new_list.connected_cells;
    alive_cells{iter+1}= new_list.alive_cells;
    dead_cells{iter+1}=new_list.dead_cells;
    % Note: disconnected cells are determined to be dead if they pass the
    % following test:
    
    
    %------------------------------------------------------% 
    % Conduct analysis on group B: potentially disconnected cells
    % - Test for synchrony
    % - Test for small events (OASIS)
    
    if sum(disconnected_cells{iter+1})>0
        %         if small_psc_events == 1
        %
        %         end
        if synchrony_test == 1
            [disconnected_indicators] = test_synchrony(disconnected_cells{iter+1},connected_cells{iter+1}+alive_cells{iter+1},...
                related_cell_list,mpp_connected,mpp_undefined,loc_to_cell,loc_to_cell_nuclei,background_rate,gamma_bound);
            disconnected_to_dead=find(disconnected_indicators & disconnected_cells{iter});
            disconnected_to_connected=find( (~disconnected_indicators) & disconnected_cells{iter});
        else
            disconnected_to_dead=find(disconnected_cells{iter+1});
            disconnected_to_connected=[];
        end
    else
        disconnected_to_dead=[];
        disconnected_to_connected=[];
    end
    %-------------------------------------------------------------%
    dead_cells{iter+1}(disconnected_to_dead)=1;
    disconnected_cells{iter+1}(disconnected_to_dead)=0;
    disconnected_cells{iter+1}(disconnected_to_connected)=0;
    connected_cells{iter+1}(disconnected_to_connected)=1; 
    
    if (sum(dead_cells{iter+1})+sum(alive_cells{iter+1}))  == length(alive_cells{iter+1})
    connected_cells{iter+1}(find(alive_cells{iter+1}))=1;
    end

